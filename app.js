/**
 * Keep 风格收藏应用 - 本地文件系统版
 * 功能：基于 File System Access API 直接读写本地 Markdown 文件
 */

// ===== 常量配置 =====
const API_URL = 'https://api.microlink.io';
const CLOUDFRONT_ERROR_PATTERNS = [
  /error:\s*the request could not be satisfied/i,
  /403\s*error/i,
  /generated by cloudfront/i,
  /request blocked/i
];
const DB_NAME = 'keep-db';
const STORE_NAME = 'handles';
const X_WIDGETS_SCRIPT_SRC = 'https://platform.twitter.com/widgets.js';
const X_WIDGETS_SCRIPT_ID = 'xWidgetsScript';

// ===== IndexedDB 简易封装 =====
const db = {
  db: null,
  async open() {
    if (this.db) return this.db;
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, 1);
      request.onupgradeneeded = (e) => {
        e.target.result.createObjectStore(STORE_NAME);
      };
      request.onsuccess = (e) => {
        this.db = e.target.result;
        resolve(this.db);
      };
      request.onerror = (e) => reject(e);
    });
  },
  async get(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },
  async set(key, value) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const req = store.put(value, key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
};

// ===== DOM 元素 =====
const elements = {
  // 布局容器
  folderPrompt: document.getElementById('folderPrompt'),
  mainContent: document.getElementById('mainContent'),
  promptTitle: document.querySelector('#folderPrompt h2'),
  promptDesc: document.querySelector('#folderPrompt p'),
  openFolderBtn: document.getElementById('openFolderBtn'),

  // Header
  folderName: document.getElementById('folderName'),
  changeFolderBtn: document.getElementById('changeFolderBtn'),

  // 输入框
  addSection: document.querySelector('.add-section'),
  addBox: document.getElementById('addBox'),
  addBoxCollapsed: document.getElementById('addBoxCollapsed'),
  noteForm: document.getElementById('noteForm'),

  // 笔记输入
  noteContentInput: document.getElementById('noteContentInput'),
  closeNoteForm: document.getElementById('closeNoteForm'),
  saveNoteBtn: document.getElementById('saveNoteBtn'),

  // 卡片
  cardsGrid: document.getElementById('cardsGrid'),
  emptyState: document.getElementById('emptyState'),
  emptyStateText: document.querySelector('#emptyState p'),

  // 模板
  linkCardTemplate: document.getElementById('linkCardTemplate'),
  linkLoadingTemplate: document.getElementById('linkLoadingTemplate'),
  noteCardTemplate: document.getElementById('noteCardTemplate'),

  // 侧边栏元素
  sidebarOverlay: null, // lazily initialized in showSidebarOverlay
  sidebarToggleBtn: document.getElementById('sidebarToggleBtn'),
  sidebar: document.getElementById('tagSidebar'),
  closeSidebarBtn: document.getElementById('closeSidebarBtn'),
  viewNotesBtn: document.getElementById('viewNotesBtn'),
  viewTrashBtn: document.getElementById('viewTrashBtn'),
  searchInput: document.getElementById('searchInput'),
  clearSearchBtn: document.getElementById('clearSearchBtn'),
  typeFiltersCard: document.getElementById('typeFiltersCard'),
  typeFiltersList: document.getElementById('typeFiltersList'),
  tagsList: document.getElementById('tagsList'),
  tagsSection: document.getElementById('tagsSection'),
  activeFilters: document.getElementById('activeFilters'),
  activeFiltersList: document.getElementById('activeFiltersList'),
  clearAllFiltersBtn: document.getElementById('clearAllFilters'),
  noTagsState: document.getElementById('noTagsState'),
};

// ===== 编辑弹窗 DOM =====
const editModal = {
  modal: document.getElementById('editModal'),
  editorContainer: document.getElementById('editContentEditor'),
  textarea: document.getElementById('editContentTextarea'),
  titleInput: document.getElementById('editTitleInput'),
  titleError: document.getElementById('editTitleError'),
  tagsContainer: document.getElementById('editTagsContainer'),
  charCount: document.querySelector('.char-count'),
  saveBtn: document.querySelector('.btn-save-edit'),
  backdrop: document.querySelector('.edit-modal-backdrop')
};

// ===== 链接编辑弹窗 DOM =====
const linkEditModal = {
  modal: document.getElementById('linkEditModal'),
  form: document.getElementById('linkEditForm'),
  coverPreview: document.getElementById('linkCoverPreview'),
  coverPreviewImage: document.getElementById('linkCoverPreviewImage'),
  coverPreviewHint: document.getElementById('linkCoverPreviewHint'),
  tagsContainer: document.getElementById('linkEditTagsContainer'),
  saveBtn: document.querySelector('.btn-save-link-edit'),
  backdrop: document.querySelector('#linkEditModal .edit-modal-backdrop')
};

// ===== 状态管理 =====
let dirHandle = null;
let items = []; // { id, content, createdAt, handle }
const pendingUrls = new Set();
const VIEW_ACTIVE = 'active';
const VIEW_TRASH = 'trash';
let currentView = VIEW_ACTIVE;
let searchQuery = '';

// 标签筛选状态
let selectedTags = new Set();  // 存储选中的标签名称
let allTags = [];              // 存储唯一标签及其计数: [{ name: 'tech', count: 5 }, ...]
let selectedType = null;       // 存储选中的类型（单选）：note/link/image
let allTypes = [];             // 存储类型及其计数: [{ name: 'note', count: 3 }, ...]

// 编辑相关状态
let currentEditingItem = null;
let noteEditorView = null;
let noteEditorLoader = null;
let popupHideTimer = null;
let xWidgetsLoadPromise = null;

// TagsInput 组件实例
let editTagsInput = null;
let linkEditTagsInput = null;

function isTextEditingTarget(target) {
  if (!(target instanceof Element)) return false;

  const editingSelector = 'input, textarea, select, [contenteditable="true"], .tags-input-field, .tags-input-container';
  if (target.closest(editingSelector)) return true;

  const editableAncestor = target.closest('[contenteditable]');
  if (!editableAncestor) return false;

  const contentEditableValue = editableAncestor.getAttribute('contenteditable');
  return contentEditableValue !== 'false';
}

function isMetaOrCtrlEnter(e) {
  return e.key === 'Enter' && (e.metaKey || e.ctrlKey);
}

function isNoteFormOpen() {
  return !elements.noteForm.classList.contains('hidden');
}

function isNoteEditOpen() {
  return !editModal.modal.classList.contains('hidden');
}

function isLinkEditOpen() {
  return !linkEditModal.modal.classList.contains('hidden');
}

function autoResizeNoteContentInput() {
  const textarea = elements.noteContentInput;
  if (!textarea) return;

  const maxHeightValue = getComputedStyle(textarea).maxHeight;
  const maxHeight = Number.parseFloat(maxHeightValue);
  const safeMaxHeight = Number.isFinite(maxHeight) ? maxHeight : 220;

  textarea.style.height = 'auto';
  const nextHeight = Math.min(textarea.scrollHeight, safeMaxHeight);
  textarea.style.height = `${nextHeight}px`;
  textarea.style.overflowY = textarea.scrollHeight > safeMaxHeight ? 'auto' : 'hidden';
}

function showPopup(message, type = 'success') {
  let popup = document.getElementById('appPopup');
  if (!popup) {
    popup = document.createElement('div');
    popup.id = 'appPopup';
    popup.className = 'app-popup';
    popup.setAttribute('role', 'status');
    popup.setAttribute('aria-live', 'polite');
    document.body.appendChild(popup);
  }

  popup.textContent = message;
  popup.classList.remove('show', 'success', 'error');
  popup.classList.add(type === 'error' ? 'error' : 'success');

  // Force reflow to replay animation for rapid repeated copies.
  void popup.offsetHeight;
  popup.classList.add('show');

  if (popupHideTimer) clearTimeout(popupHideTimer);
  popupHideTimer = setTimeout(() => {
    popup.classList.remove('show');
  }, 1500);
}

// ===== TagsInput 组件 =====
class TagsInput {
  constructor(container, options = {}) {
    this.tags = [];
    this.container = container;
    this.placeholder = options.placeholder || 'Add tag (press Enter)';
    this.maxTags = options.maxTags || Infinity;
    this.onChange = options.onChange || (() => {});
    this.enableSuggestions = options.enableSuggestions || false;
    this.suggestionsProvider = options.suggestionsProvider || (() => []);
    this.matchMode = options.matchMode || 'includes';
    this.suggestions = [];
    this.isFocused = false;
    this.blurTimeout = null;
    this.activeSuggestionIndex = -1;

    this.init();
  }

  init() {
    this.container.classList.add('tags-input-container');

    // 创建输入框
    this.input = document.createElement('input');
    this.input.type = 'text';
    this.input.className = 'tags-input-field';
    this.input.placeholder = this.placeholder;
    this.container.appendChild(this.input);

    if (this.enableSuggestions) {
      this.suggestionsContainer = document.createElement('div');
      this.suggestionsContainer.className = 'tags-suggestions hidden';
      this.container.appendChild(this.suggestionsContainer);
    }

    // 绑定事件
    this.input.addEventListener('keydown', (e) => this.handleKeyDown(e));
    this.input.addEventListener('input', () => this.handleInput());
    this.input.addEventListener('focus', () => this.handleFocus());
    this.input.addEventListener('blur', () => this.handleBlur());
  }

  handleKeyDown(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (this.enableSuggestions && this.activeSuggestionIndex >= 0 && this.suggestions[this.activeSuggestionIndex]) {
        this.handleSuggestionClick(this.suggestions[this.activeSuggestionIndex]);
        return;
      }
      this.addTag(this.input.value.trim());
    } else if (e.key === 'Tab' && this.enableSuggestions && this.suggestions.length > 0) {
      e.preventDefault();
      const direction = e.shiftKey ? -1 : 1;
      if (this.activeSuggestionIndex < 0) {
        this.activeSuggestionIndex = direction === 1 ? 0 : this.suggestions.length - 1;
      } else {
        this.activeSuggestionIndex = (this.activeSuggestionIndex + direction + this.suggestions.length) % this.suggestions.length;
      }
      this.renderSuggestions();
    } else if (e.key === 'Backspace' && this.input.value === '' && this.tags.length > 0) {
      this.removeTag(this.tags.length - 1);
    } else if (e.key === ',' && this.input.value.trim()) {
      e.preventDefault();
      this.addTag(this.input.value.trim());
    }
  }

  handleInput() {
    if (!this.enableSuggestions) return;
    this.activeSuggestionIndex = -1;
    this.renderSuggestions();
  }

  handleFocus() {
    this.isFocused = true;
    this.showSuggestions();
  }

  handleBlur() {
    this.isFocused = false;
    clearTimeout(this.blurTimeout);
    this.blurTimeout = setTimeout(() => {
      // 失焦时如果有内容，尝试添加为标签
      const value = this.input.value.trim();
      if (value) {
        this.addTag(value);
      }
      this.activeSuggestionIndex = -1;
      this.hideSuggestions();
    }, 120);
  }

  addTag(text) {
    const trimmed = text.trim();
    if (!trimmed) return;
    if (this.tags.includes(trimmed)) {
      this.input.value = '';
      return;
    }
    if (this.tags.length >= this.maxTags) {
      showPopup('You can add up to ' + this.maxTags + ' tags', 'error');
      return;
    }

    this.tags.push(trimmed);
    this.render();
    this.input.value = '';
    this.onChange(this.tags);
    this.refreshSuggestions();
  }

  removeTag(index) {
    this.tags.splice(index, 1);
    this.render();
    this.onChange(this.tags);
    this.refreshSuggestions();
  }

  getTags() {
    return [...this.tags];
  }

  setTags(tags) {
    this.tags = Array.isArray(tags) ? [...tags] : [];
    this.render();
    this.onChange(this.tags);
    this.refreshSuggestions();
  }

  clear() {
    this.tags = [];
    this.render();
    this.onChange(this.tags);
    this.refreshSuggestions();
  }

  render() {
    // 移除旧的标签元素（保留输入框）
    const oldTags = this.container.querySelectorAll('.tag');
    oldTags.forEach(t => t.remove());

    // 在输入框之前插入标签
    this.tags.forEach((tag, index) => {
      const tagEl = document.createElement('span');
      tagEl.className = 'tag';
      tagEl.innerHTML = `
        ${escapeHtml(tag)}
        <span class="tag-remove" data-index="${index}">&times;</span>
      `;

      // 点击删除按钮
      tagEl.querySelector('.tag-remove').addEventListener('click', (e) => {
        e.stopPropagation();
        this.removeTag(index);
      });

      this.container.insertBefore(tagEl, this.input);
    });

    this.refreshSuggestions();
  }

  getFilteredSuggestions(query) {
    if (!this.enableSuggestions) return [];

    const normalizedQuery = (query || '').toLowerCase();
    const usedTags = new Set(this.tags);
    const seen = new Set();
    const sourceTags = this.suggestionsProvider();

    const candidates = sourceTags
      .map(tag => typeof tag === 'string' ? tag.trim() : '')
      .filter(tag => {
        if (!tag) return false;
        if (usedTags.has(tag)) return false;
        if (seen.has(tag)) return false;
        seen.add(tag);
        return true;
      });

    return candidates.filter(tag => {
      const normalizedTag = tag.toLowerCase();
      if (!normalizedQuery) return true;
      if (this.matchMode === 'prefix') return normalizedTag.startsWith(normalizedQuery);
      if (this.matchMode === 'exact') return normalizedTag === normalizedQuery;
      return normalizedTag.includes(normalizedQuery);
    });
  }

  renderSuggestions() {
    if (!this.enableSuggestions || !this.suggestionsContainer) return;

    const query = this.input.value.trim();
    this.suggestions = this.getFilteredSuggestions(query);
    if (this.activeSuggestionIndex >= this.suggestions.length) {
      this.activeSuggestionIndex = -1;
    }
    this.suggestionsContainer.innerHTML = '';

    if (!this.isFocused || this.suggestions.length === 0) {
      this.suggestionsContainer.classList.add('hidden');
      return;
    }

    this.suggestions.forEach(tag => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'tag-suggestion-item';
      if (this.suggestions[this.activeSuggestionIndex] === tag) {
        item.classList.add('selected');
      }
      item.textContent = tag;
      item.addEventListener('mousedown', (e) => e.preventDefault());
      item.addEventListener('click', () => this.handleSuggestionClick(tag));
      this.suggestionsContainer.appendChild(item);
    });

    this.suggestionsContainer.classList.remove('hidden');
  }

  showSuggestions() {
    if (!this.enableSuggestions) return;
    this.renderSuggestions();
  }

  hideSuggestions() {
    if (!this.enableSuggestions || !this.suggestionsContainer) return;
    this.suggestionsContainer.classList.add('hidden');
  }

  handleSuggestionClick(tag) {
    this.activeSuggestionIndex = -1;
    this.addTag(tag);
    this.input.value = '';
    this.showSuggestions();
    this.focus();
  }

  refreshSuggestions() {
    if (!this.enableSuggestions) return;
    this.renderSuggestions();
  }

  focus() {
    this.input.focus();
  }
}

// ===== 侧边栏筛选功能 =====
const TYPE_FILTER_ORDER = ['note', 'link', 'image'];

/**
 * 从所有项目中提取唯一标签并计数
 * 按字母顺序排序
 * @returns {Array} 标签数组 [{ name, count }]
 */
function extractAllTags() {
  const tagMap = new Map();

  items.forEach(item => {
    const { data } = parseFrontMatter(item.content);
    if (data.tags) {
      const tags = data.tags.split(',').map(t => t.trim()).filter(t => t);
      tags.forEach(tag => {
        const count = tagMap.get(tag) || 0;
        tagMap.set(tag, count + 1);
      });
    }
  });

  // 转换为数组并按字母顺序排序
  const sortedTags = Array.from(tagMap.entries())
    .map(([name, count]) => ({ name, count }))
    .sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

  return sortedTags;
}

/**
 * 从所有项目中提取类型并计数
 * 按固定顺序输出: note -> link -> image
 * @returns {Array} 类型数组 [{ name, count }]
 */
function extractAllTypes() {
  const typeMap = new Map();

  items.forEach(item => {
    const { data } = parseFrontMatter(item.content || '');
    const type = (data.type || '').trim().toLowerCase();
    if (!TYPE_FILTER_ORDER.includes(type)) return;
    const count = typeMap.get(type) || 0;
    typeMap.set(type, count + 1);
  });

  return TYPE_FILTER_ORDER
    .filter(type => typeMap.has(type))
    .map(type => ({ name: type, count: typeMap.get(type) || 0 }));
}

/**
 * 更新侧边栏筛选列表
 */
function updateSidebarTags() {
  allTags = extractAllTags();
  allTypes = extractAllTypes();
  renderSidebarFilters();
  refreshTagSuggestions();
}

function refreshTagSuggestions() {
  if (editTagsInput) editTagsInput.refreshSuggestions();
  if (linkEditTagsInput) linkEditTagsInput.refreshSuggestions();
}

function updateViewControls() {
  elements.viewNotesBtn.classList.toggle('active', currentView === VIEW_ACTIVE);
  elements.viewTrashBtn.classList.toggle('active', currentView === VIEW_TRASH);
  elements.addSection.classList.toggle('hidden', currentView === VIEW_TRASH);
}

function refreshFeatherIcons() {
  if (window.feather && typeof window.feather.replace === 'function') {
    window.feather.replace();
  }
}

/**
 * 渲染侧边栏中的筛选（类型 + 标签）
 */
function renderSidebarFilters() {
  elements.typeFiltersList.innerHTML = '';
  elements.tagsList.innerHTML = '';

  // 显示/隐藏空状态
  if (allTags.length === 0 && allTypes.length === 0) {
    elements.noTagsState.classList.remove('hidden');
    elements.typeFiltersCard.classList.add('hidden');
    elements.tagsSection.classList.add('hidden');
    updateActiveFilters();
    refreshFeatherIcons();
    return;
  }

  elements.noTagsState.classList.add('hidden');
  elements.typeFiltersCard.classList.toggle('hidden', allTypes.length === 0);
  elements.tagsSection.classList.toggle('hidden', allTags.length === 0);

  // 渲染类型筛选
  allTypes.forEach(type => {
    const typeEl = createTypeFilterElement(type);
    elements.typeFiltersList.appendChild(typeEl);
  });

  // 渲染标签筛选
  allTags.forEach(tag => {
    const tagEl = createTagFilterElement(tag);
    elements.tagsList.appendChild(tagEl);
  });

  // 更新已选筛选显示
  updateActiveFilters();
  refreshFeatherIcons();
}

/**
 * 创建筛选元素
 * @param {Object} filter - { name, count }
 * @param {boolean} isSelected
 * @param {Function} onClick
 * @returns {HTMLElement}
 */
function createFilterElement(filter, isSelected, onClick) {
  const item = document.createElement('div');
  item.className = `tag-filter-item${isSelected ? ' selected' : ''}`;
  item.dataset.filter = filter.name;

  item.innerHTML = `
    <div class="tag-filter-checkbox">
      <i data-feather="check" aria-hidden="true"></i>
    </div>
    <span class="tag-filter-name">${escapeHtml(filter.name)}</span>
    <span class="tag-filter-count">${filter.count}</span>
  `;

  item.addEventListener('click', onClick);

  return item;
}

function createTagFilterElement(tag) {
  return createFilterElement(
    tag,
    selectedTags.has(tag.name),
    () => toggleTagFilter(tag.name)
  );
}

function createTypeFilterElement(type) {
  return createFilterElement(
    type,
    selectedType === type.name,
    () => toggleTypeFilter(type.name)
  );
}

/**
 * HTML 转义，防止 XSS
 * @param {string} text
 * @returns {string}
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

/**
 * 切换标签选择状态
 * @param {string} tagName
 */
function toggleTagFilter(tagName) {
  if (selectedTags.has(tagName)) {
    selectedTags.delete(tagName);
  } else {
    selectedTags.add(tagName);
  }

  renderSidebarFilters();
  filterAndRenderItems();
}

/**
 * 切换类型选择状态（单选）
 * @param {string} typeName
 */
function toggleTypeFilter(typeName) {
  selectedType = selectedType === typeName ? null : typeName;
  renderSidebarFilters();
  filterAndRenderItems();
}

/**
 * 清除所有筛选
 */
function clearAllFilters() {
  selectedTags.clear();
  selectedType = null;
  renderSidebarFilters();
  filterAndRenderItems();
}

function handleSearchInput(e) {
  searchQuery = (e.target.value || '').trim().toLowerCase();
  updateSearchClearButton();
  filterAndRenderItems();
}

function handleSearchKeydown(e) {
  if (e.key !== 'Escape') return;
  e.preventDefault();
  e.stopPropagation();
  elements.searchInput.blur();
}

function clearSearchQuery() {
  elements.searchInput.value = '';
  searchQuery = '';
  updateSearchClearButton();
  filterAndRenderItems();
}

function updateSearchClearButton() {
  const hasQuery = Boolean(elements.searchInput.value.trim());
  elements.clearSearchBtn.classList.toggle('hidden', !hasQuery);
}

/**
 * 更新已选筛选显示
 */
function updateActiveFilters() {
  if (selectedTags.size === 0 && !selectedType) {
    elements.activeFilters.classList.add('hidden');
    return;
  }

  elements.activeFilters.classList.remove('hidden');
  elements.activeFiltersList.innerHTML = '';

  if (selectedType) {
    const typeEl = document.createElement('span');
    typeEl.className = 'tag';
    typeEl.innerHTML = `
      ${escapeHtml(`type: ${selectedType}`)}
      <span class="tag-remove" data-type="${selectedType}">&times;</span>
    `;

    typeEl.querySelector('.tag-remove').addEventListener('click', (e) => {
      e.stopPropagation();
      toggleTypeFilter(selectedType);
    });

    elements.activeFiltersList.appendChild(typeEl);
  }

  selectedTags.forEach(tagName => {
    const tagEl = document.createElement('span');
    tagEl.className = 'tag';
    tagEl.innerHTML = `
      ${escapeHtml(tagName)}
      <span class="tag-remove" data-tag="${tagName}">&times;</span>
    `;

    tagEl.querySelector('.tag-remove').addEventListener('click', (e) => {
      e.stopPropagation();
      toggleTagFilter(tagName);
    });

    elements.activeFiltersList.appendChild(tagEl);
  });
}

/**
 * 根据选中的标签筛选项目（AND 逻辑）
 * @returns {Array} 筛选后的项目
 */
function matchesTagFilters(item) {
  if (selectedTags.size === 0) {
    return true;
  }

  const { data } = parseFrontMatter(item.content || '');
  if (!data.tags) return false;

  const itemTags = data.tags.split(',').map(t => t.trim()).filter(t => t);

  // 检查项目是否包含所有选中的标签（AND 逻辑）
  return [...selectedTags].every(selectedTag => itemTags.includes(selectedTag));
}

function matchesTypeFilter(item) {
  if (!selectedType) return true;
  const { data } = parseFrontMatter(item.content || '');
  return data.type === selectedType;
}

function buildSearchText(item) {
  const { data, content } = parseFrontMatter(item.content || '');
  const tags = data.tags || '';

  if (isLinkItemType(data.type)) {
    return [item.id, data.title, data.description, data.url, tags]
      .filter(Boolean)
      .join('\n')
      .toLowerCase();
  }

  return [item.id, content, tags]
    .filter(Boolean)
    .join('\n')
    .toLowerCase();
}

function matchesSearchQuery(item) {
  if (!searchQuery) return true;
  return buildSearchText(item).includes(searchQuery);
}

function getFilteredItems() {
  return items.filter(item => matchesTagFilters(item) && matchesTypeFilter(item) && matchesSearchQuery(item));
}

/**
 * 筛选并渲染项目
 */
function filterAndRenderItems() {
  const filteredItems = getFilteredItems();

  elements.cardsGrid.innerHTML = '';
  filteredItems.forEach(item => renderOneItem(item, false));
  updateEmptyState();
  refreshFeatherIcons();
}

/**
 * 切换侧边栏（移动端）
 */
function toggleSidebar() {
  elements.sidebar.classList.toggle('open');

  if (elements.sidebar.classList.contains('open')) {
    showSidebarOverlay();
  } else {
    hideSidebarOverlay();
  }
}

/**
 * 显示遮罩层
 */
function showSidebarOverlay() {
  if (!elements.sidebarOverlay) {
    const overlay = document.createElement('div');
    overlay.className = 'sidebar-overlay';
    overlay.addEventListener('click', closeSidebar);
    document.body.appendChild(overlay);
    elements.sidebarOverlay = overlay;
  }
  elements.sidebarOverlay.classList.add('visible');
}

/**
 * 隐藏遮罩层
 */
function hideSidebarOverlay() {
  if (elements.sidebarOverlay) {
    elements.sidebarOverlay.classList.remove('visible');
  }
}

/**
 * 关闭侧边栏
 */
function closeSidebar() {
  elements.sidebar.classList.remove('open');
  hideSidebarOverlay();
}

// ===== 初始化 =====
async function init() {
  // 初始化 TagsInput 组件
  editTagsInput = new TagsInput(editModal.tagsContainer, {
    enableSuggestions: true,
    matchMode: 'includes',
    suggestionsProvider: () => allTags.map(t => t.name)
  });
  linkEditTagsInput = new TagsInput(linkEditModal.tagsContainer, {
    enableSuggestions: true,
    matchMode: 'includes',
    suggestionsProvider: () => allTags.map(t => t.name)
  });

  bindEvents();
  bindEditModalEvents();
  bindLinkEditModalEvents();

  // 检查是否有缓存的句柄
  try {
    const handle = await db.get('dirHandle');
    if (handle) {
      dirHandle = handle;
      // 更新 UI 为"恢复模式"
      elements.promptTitle.textContent = `Continue with "${handle.name}"?`;
      elements.promptDesc.innerHTML = 'For security, your browser needs you to confirm access again.';
      elements.openFolderBtn.textContent = 'Restore access';
    }
  } catch (e) {
    console.warn('DB error:', e);
  }

  refreshFeatherIcons();
}

let eventsBound = false;

// marked 默认会给任务列表 checkbox 加 disabled。
// 这里覆盖渲染器，允许在卡片中直接交互。
const markedRenderer = new marked.Renderer();
markedRenderer.checkbox = function checkboxRenderer(arg) {
  const checked = typeof arg === 'boolean' ? arg : Boolean(arg && arg.checked);
  return `<input type="checkbox"${checked ? ' checked' : ''}>`;
};
marked.use({ renderer: markedRenderer });

// ===== 事件绑定 =====
function bindEvents() {
  if (eventsBound) return;
  eventsBound = true;

  // 文件夹操作
  elements.openFolderBtn.addEventListener('click', handleOpenFolder);
  elements.changeFolderBtn.addEventListener('click', handleChangeFolder);

  // 点击收起的输入框展开笔记表单
  elements.addBoxCollapsed.addEventListener('click', expandNoteForm);

  // 关闭表单
  elements.closeNoteForm.addEventListener('click', collapseForm);

  // 提交表单
  elements.noteForm.addEventListener('submit', handleNoteSubmit);
  elements.noteContentInput.addEventListener('input', autoResizeNoteContentInput);

  // 点击外部关闭表单
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.add-box') && !elements.addBoxCollapsed.classList.contains('hidden')) {
      return;
    }
    if (!e.target.closest('.add-box')) {
      collapseForm();
    }
  });

  // 卡片操作
  elements.cardsGrid.addEventListener('click', handleCardClick);
  elements.cardsGrid.addEventListener('change', handleCardCheckboxChange);

  // 侧边栏切换
  elements.sidebarToggleBtn.addEventListener('click', toggleSidebar);
  elements.closeSidebarBtn.addEventListener('click', closeSidebar);
  elements.viewNotesBtn.addEventListener('click', () => switchView(VIEW_ACTIVE));
  elements.viewTrashBtn.addEventListener('click', () => switchView(VIEW_TRASH));
  elements.searchInput.addEventListener('input', handleSearchInput);
  elements.searchInput.addEventListener('keydown', handleSearchKeydown);
  elements.clearSearchBtn.addEventListener('click', clearSearchQuery);

  // 清除所有筛选
  elements.clearAllFiltersBtn.addEventListener('click', clearAllFilters);

  // 键盘快捷键
  document.addEventListener('keydown', async (e) => {
    // ESC 关闭侧边栏
    if (e.key === 'Escape' && elements.sidebar.classList.contains('open')) {
      closeSidebar();
      return;
    }

    // ESC 关闭主输入框（焦点在输入区域内时）
    if (
      e.key === 'Escape' &&
      isNoteFormOpen() &&
      !isNoteEditOpen() &&
      !isLinkEditOpen() &&
      elements.noteForm.contains(document.activeElement)
    ) {
      e.preventDefault();
      collapseForm();
      return;
    }

    // n: 快速聚焦主输入框（仅非输入态，且无编辑弹窗）
    if (
      e.key.toLowerCase() === 'n' &&
      !e.metaKey &&
      !e.ctrlKey &&
      !e.altKey &&
      !isTextEditingTarget(e.target) &&
      !isNoteEditOpen() &&
      !isLinkEditOpen()
    ) {
      e.preventDefault();
      if (!isNoteFormOpen()) {
        expandNoteForm();
      }
      elements.noteContentInput.focus();
      return;
    }

    // /: 快速聚焦搜索框（仅非输入态，且无编辑弹窗）
    if (
      e.key === '/' &&
      !e.metaKey &&
      !e.ctrlKey &&
      !e.altKey &&
      !isTextEditingTarget(e.target) &&
      !isNoteEditOpen() &&
      !isLinkEditOpen()
    ) {
      e.preventDefault();
      if (!elements.sidebar.classList.contains('open') && window.innerWidth <= 1024) {
        elements.sidebar.classList.add('open');
        showSidebarOverlay();
      }
      elements.searchInput.focus();
      elements.searchInput.select();
      return;
    }

    // Cmd/Ctrl + Enter: 统一保存
    if (isMetaOrCtrlEnter(e)) {
      // 1) 笔记编辑弹窗
      if (isNoteEditOpen()) {
        e.preventDefault();
        if (editModal.saveBtn.disabled) return;
        const saved = await saveEditedNote();
        if (saved) {
          editModal.modal.classList.add('hidden');
        }
        return;
      }

      // 2) 链接编辑弹窗
      if (isLinkEditOpen()) {
        e.preventDefault();
        if (linkEditModal.saveBtn.disabled) return;
        const saved = await saveLinkEdit();
        if (saved) {
          linkEditModal.modal.classList.add('hidden');
        }
        return;
      }

      // 3) 主输入框
      if (isNoteFormOpen()) {
        e.preventDefault();
        elements.noteForm.requestSubmit();
      }
    }
  });
}

// ===== 文件系统操作 =====
async function handleOpenFolder() {
  try {
    // 如果已有 handle，尝试 verifyPermission
    if (dirHandle) {
      const permission = await verifyPermission(dirHandle, true);
      if (permission) {
        await finishSetupFolder();
        return;
      }
      // 如果 verify 失败（用户拒绝），则重新通过 picker 选择
    }

    // 打开选择器
    const handle = await window.showDirectoryPicker();
    dirHandle = handle;
    await db.set('dirHandle', handle);

    await finishSetupFolder();

  } catch (e) {
    if (e.name !== 'AbortError') {
      console.error('Failed to open folder:', e);
      showPopup('Failed to open folder. Please try again.', 'error');
    }
  }
}

async function handleChangeFolder() {
  const previousDirHandle = dirHandle;
  const previousItems = [...items];
  const previousView = currentView;
  const previousFolderName = elements.folderName.textContent;
  const previousSearchQuery = searchQuery;

  try {
    const handle = await window.showDirectoryPicker();
    await db.set('dirHandle', handle);

    dirHandle = handle;
    await finishSetupFolder();
  } catch (e) {
    if (e.name === 'AbortError') return;

    console.error('Failed to change folder:', e);
    showPopup('Failed to change folder. Please try again.', 'error');

    dirHandle = previousDirHandle;
    items = previousItems;
    currentView = previousView;
    searchQuery = previousSearchQuery;
    elements.folderName.textContent = previousFolderName;
    elements.searchInput.value = previousSearchQuery;

    updateViewControls();
    updateSidebarTags();
    filterAndRenderItems();
    updateEmptyState();
  }
}

async function finishSetupFolder() {
  elements.folderName.textContent = dirHandle.name;
  elements.folderPrompt.classList.add('hidden');
  elements.mainContent.classList.remove('hidden');
  currentView = VIEW_ACTIVE;
  updateViewControls();

  await loadItems(currentView);
  updateEmptyState();
}

async function verifyPermission(fileHandle, readWrite) {
  const options = {};
  if (readWrite) {
    options.mode = 'readwrite';
  }

  // Check if permission was already granted
  if ((await fileHandle.queryPermission(options)) === 'granted') {
    return true;
  }

  // Request permission
  if ((await fileHandle.requestPermission(options)) === 'granted') {
    return true;
  }

  return false;
}

// ===== 数据加载 (R) =====
async function getItemsDirectoryHandle(view) {
  if (!dirHandle) return null;
  if (view === VIEW_ACTIVE) return dirHandle;

  try {
    return await dirHandle.getDirectoryHandle('.trash');
  } catch (e) {
    if (e.name === 'NotFoundError') return null;
    throw e;
  }
}

async function loadItems(view = currentView) {
  if (!dirHandle) return;

  items = [];
  elements.cardsGrid.innerHTML = ''; // Clear current

  try {
    const targetHandle = await getItemsDirectoryHandle(view);
    if (targetHandle) {
      for await (const entry of targetHandle.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.md')) {
          const file = await entry.getFile();
          let text = await file.text();

          if (view === VIEW_ACTIVE) {
            const normalized = normalizeItemTypeInContent(text);
            if (normalized !== text) {
              const writable = await entry.createWritable();
              await writable.write(normalized);
              await writable.close();
              text = normalized;
            }
          }

          const stat = file.lastModified;

          items.push({
            id: entry.name.replace('.md', ''), // Use filename as ID
            content: text,
            createdAt: stat,
            fileName: entry.name,
            handle: entry
          });
        }
      }
    }

    // Sort by created/modified time (desc)
    items.sort((a, b) => b.createdAt - a.createdAt);
    renderItems();
    updateSidebarTags();

  } catch (e) {
    console.error('Failed to load items:', e);
    showPopup('Failed to read files.', 'error');
  }
}

async function switchView(view) {
  if (!dirHandle || view === currentView) return;
  currentView = view;
  selectedTags.clear();
  collapseForm();
  updateViewControls();
  await loadItems(currentView);
}

// ===== 数据写入 (C/U) =====
async function saveFile(filename, content) {
  try {
    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });

    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    return fileHandle;
  } catch (e) {
    console.error('Save file failed:', e);
    throw e;
  }
}

async function deleteFile(filename) {
  try {
    // 1. 获取/创建 .trash 文件夹
    const trashHandle = await dirHandle.getDirectoryHandle('.trash', { create: true });

    // 2. 获取源文件句柄
    const fileHandle = await dirHandle.getFileHandle(filename);

    // 3. 尝试移动 (支持 Chrome 109+ 等现代浏览器)
    if (fileHandle.move) {
      await fileHandle.move(trashHandle);
    } else {
      // 兼容处理：复制 -> 删除
      const file = await fileHandle.getFile();
      const content = await file.text();

      // 在 trash 中新建
      const newFileHandle = await trashHandle.getFileHandle(filename, { create: true });
      const writable = await newFileHandle.createWritable();
      await writable.write(content);
      await writable.close();

      // 删除原文件
      await dirHandle.removeEntry(filename);
    }
  } catch (e) {
    console.error('Move to trash failed:', e);
    throw e;
  }
}

async function deleteTrashFile(filename) {
  try {
    const trashHandle = await dirHandle.getDirectoryHandle('.trash');
    await trashHandle.removeEntry(filename);
  } catch (e) {
    console.error('Delete from trash failed:', e);
    throw e;
  }
}

/**
 * 重命名文件
 * @param {string} oldFilename - 旧文件名（如 "MyNote.md"）
 * @param {string} newFilename - 新文件名（如 "NewTitle.md"）
 */
async function renameFile(oldFilename, newFilename) {
  try {
    const fileHandle = await dirHandle.getFileHandle(oldFilename);

    // 优先使用 move API（Chrome 109+）
    if (fileHandle.move) {
      await fileHandle.move(dirHandle, newFilename);
      return;
    }

    // 兼容处理：复制新文件 -> 删除旧文件
    const file = await fileHandle.getFile();
    const content = await file.text();

    const newFileHandle = await dirHandle.getFileHandle(newFilename, { create: true });
    const writable = await newFileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    await dirHandle.removeEntry(oldFilename);
  } catch (e) {
    console.error('Rename file failed:', e);
    throw e;
  }
}

// ===== 业务逻辑：添加笔记/链接 =====
async function handleNoteSubmit(e) {
  e.preventDefault();

  const content = elements.noteContentInput.value.trim();

  if (!content) {
    collapseForm();
    return;
  }

  // 单行链接检查
  if (isValidUrl(content)) {
    elements.noteContentInput.value = '';
    collapseForm(); // 提前关闭表单
    await addLinkItem(content, []);
  } else {
    // 普通笔记 - 不带标题和标签
    await addItem('', content, []);

    // 清空
    elements.noteContentInput.value = '';
    collapseForm();
  }
}

async function addItem(title, content, tags = []) {
  const baseTitle = sanitizeFilename(title || generateTimestampTitle());
  const finalTitle = ensureUniqueTitle(baseTitle);
  const filename = `${finalTitle}.md`;

  // 笔记始终使用 front matter，并带 type: note
  const frontMatterData = { type: 'note' };
  if (tags.length > 0) {
    frontMatterData.tags = tags.join(',');
  }
  const finalContent = createMarkdownWithFrontMatter(frontMatterData, content);

  try {
    // 写入文件系统
    await saveFile(filename, finalContent);

    // 更新内存状态 - 使用文件名（不含扩展名）作为 id
    const newItem = {
      id: finalTitle,
      content: finalContent,
      createdAt: Date.now(),
      fileName: filename
    };

    items.unshift(newItem);

    // 渲染
    renderOneItem(newItem, true);
    updateEmptyState();
    updateSidebarTags();

  } catch (e) {
    showPopup('Save failed: ' + e.message, 'error');
  }
}

async function addLinkItem(url, tags = []) {
  if (items.some(item => {
    const { data } = parseFrontMatter(item.content);
    return isLinkItemType(data.type) && data.url === url;
  })) {
    showPopup('This link already exists.', 'error');
    return;
  }

  if (pendingUrls.has(url)) return;
  pendingUrls.add(url);

  // Loading UI
  const loadingCard = createLoadingCard();
  elements.cardsGrid.prepend(loadingCard);
  updateEmptyState();

  try {
    const metadata = await fetchLinkMetadata(url);

    // 使用链接标题作为文件名（清理不适合文件名的字符）
    const rawTitle = metadata.title || extractReadableTitleFromUrl(url);
    const sanitizedTitle = sanitizeFilename(rawTitle);
    const uniqueTitle = ensureUniqueTitle(sanitizedTitle);
    const filename = `${uniqueTitle}.md`;

    const frontMatterData = {
      type: getLinkTypeFromUrl(url),
      title: metadata.title || extractReadableTitleFromUrl(url),
      url: url,
      description: (metadata.description || '').replace(/\n/g, ' '),
      image: metadata.image || ''
    };

    // 如果有 tags，添加到 front matter
    if (tags.length > 0) {
      frontMatterData.tags = tags.join(',');
    }

    const markdownContent = createMarkdownWithFrontMatter(frontMatterData);

    // Save to FS
    await saveFile(filename, markdownContent);

    // Update Memory - 使用文件名（不含扩展名）作为 id
    const newItem = {
      id: filename.replace('.md', ''),
      content: markdownContent,
      createdAt: Date.now(),
      fileName: filename
    };
    items.unshift(newItem);

    // Replace Card
    const realCard = createLinkCard({ ...frontMatterData, id: newItem.id });
    loadingCard.replaceWith(realCard);
    updateSidebarTags();

  } catch (e) {
    console.error('Add link failed:', e);
    showPopup('Failed to add link.', 'error');
    loadingCard.remove();
    updateEmptyState();
  } finally {
    pendingUrls.delete(url);
  }
}

// ===== 卡片交互处理 =====
async function handleCardClick(e) {
  // 1. 处理打开链接按钮点击 - 让链接正常打开，不阻止默认行为
  const openLinkBtn = e.target.closest('.open-link-button');
  if (openLinkBtn) {
    // 不阻止默认行为，让链接正常打开
    return;
  }

  // 1.1 处理任务列表 checkbox 点击：切换并持久化到 markdown 文件
  const taskCheckbox = e.target.closest('.note-content input[type="checkbox"]');
  if (taskCheckbox) {
    e.stopPropagation();
    return;
  }

  // 2. 处理复制 markdown 按钮点击（仅复制正文，不含 front matter）
  const copyMarkdownBtn = e.target.closest('.copy-markdown-button');
  if (copyMarkdownBtn) {
    e.preventDefault();
    e.stopPropagation();
    copyMarkdownBtn.blur();

    const card = copyMarkdownBtn.closest('.card');
    if (!card) return;

    const id = card.dataset.id;
    const item = items.find(i => i.id === id);
    if (!item) return;

    const { content } = parseFrontMatter(item.content || '');
    try {
      if (!navigator.clipboard?.writeText) {
        throw new Error('Clipboard API unavailable');
      }
      await navigator.clipboard.writeText(content);
      showPopup('Markdown copied');
    } catch (err) {
      showPopup('Copy failed', 'error');
    }
    return;
  }

  // 3. 处理删除按钮点击
  const deleteBtn = e.target.closest('.delete-button');
  if (deleteBtn) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    deleteBtn.blur();

    const card = deleteBtn.closest('.card');

    // 防止重复打开覆盖层
    if (card.querySelector('.card-overlay')) return;

    const id = card.dataset.id;
    const item = items.find(i => i.id === id);
    if (!item) return;

    // 创建确认覆盖层
    const overlay = document.createElement('div');
    overlay.className = 'card-overlay';
    const isTrashView = currentView === VIEW_TRASH;
    overlay.innerHTML = `
      <p>${isTrashView ? 'Delete permanently?' : 'Move to Trash?'}</p>
      <div class="overlay-actions">
        <button class="overlay-btn btn-cancel">Cancel</button>
        <button class="overlay-btn btn-confirm">Confirm</button>
      </div>
    `;

    // 绑定内部事件
    const btnCancel = overlay.querySelector('.btn-cancel');
    const btnConfirm = overlay.querySelector('.btn-confirm');

    // 阻止点击冒泡，防止触发卡片其他点击事件
    overlay.addEventListener('click', (ev) => ev.stopPropagation());

    btnCancel.addEventListener('click', (ev) => {
      ev.stopPropagation();
      overlay.remove();
    });

    btnConfirm.addEventListener('click', async (ev) => {
      ev.stopPropagation();

      // Loading 状态
      btnConfirm.textContent = '...';
      btnConfirm.style.opacity = '0.7';

      try {
        if (isTrashView) {
          await deleteTrashFile(item.fileName || `${item.id}.md`);
        } else {
          await deleteFile(item.fileName || `${item.id}.md`);
        }

        // UI 移除动画
        items = items.filter(i => i.id !== id);
        card.style.transition = 'all 0.2s ease';
        card.style.opacity = '0';
        card.style.transform = 'scale(0.9)';

        setTimeout(() => {
          if (card.parentNode) card.remove();
          updateEmptyState();
          updateSidebarTags();
        }, 200);

      } catch (err) {
        showPopup('Delete failed: ' + err.message, 'error');
        overlay.remove();
      }
    });

    card.appendChild(overlay);
    return;
  }

  // 4. 处理笔记卡片编辑点击
  const card = e.target.closest('.card');
  if (!card) return;

  const id = card.dataset.id;
  const item = items.find(i => i.id === id);
  if (!item) return;

  if (currentView === VIEW_TRASH) {
    return;
  }

  // 打开编辑弹窗（链接或笔记）
  e.preventDefault();
  e.stopPropagation();
  openEditModal(item);
}

async function handleCardCheckboxChange(e) {
  const taskCheckbox = e.target.closest('.note-content input[type="checkbox"]');
  if (!taskCheckbox) return;
  e.stopPropagation();
  await handleTaskCheckboxToggle(taskCheckbox, taskCheckbox.checked);
}

function toggleTaskInMarkdown(markdownText, taskIndex, checked) {
  const lines = markdownText.split('\n');
  const taskLinePattern = /^(\s*(?:[-*+]|\d+[.)])\s+)\[( |x|X)\](.*)$/;
  let cursor = 0;

  for (let i = 0; i < lines.length; i += 1) {
    const match = lines[i].match(taskLinePattern);
    if (!match) continue;

    if (cursor === taskIndex) {
      const prefix = match[1];
      const suffix = match[3];
      lines[i] = `${prefix}[${checked ? 'x' : ' '}]${suffix}`;
      return lines.join('\n');
    }

    cursor += 1;
  }

  return null;
}

function enhanceTaskCheckboxes(container) {
  if (!container) return;
  const boxes = container.querySelectorAll('input[type="checkbox"]');
  boxes.forEach((box, index) => {
    box.removeAttribute('disabled');
    box.disabled = false;
    box.dataset.taskIndex = String(index);
  });
}

function renderNoteMarkdown(contentEl, markdownContent) {
  const parsedHtml = marked.parse(markdownContent);
  const sanitizedHtml = sanitizeRenderedHtml(parsedHtml).replace(/\sdisabled(?:="")?/g, '');
  contentEl.innerHTML = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(sanitizedHtml) : sanitizedHtml;
  enhanceTaskCheckboxes(contentEl);
}

async function handleTaskCheckboxToggle(checkboxEl, explicitChecked) {
  const card = checkboxEl.closest('.card');
  if (!card) return;

  const id = card.dataset.id;
  const item = items.find(i => i.id === id);
  if (!item || currentView === VIEW_TRASH) return;

  const contentEl = card.querySelector('.note-content');
  if (!contentEl) return;

  const taskIndex = Number(checkboxEl.dataset.taskIndex);
  const resolvedTaskIndex = Number.isInteger(taskIndex) && taskIndex >= 0
    ? taskIndex
    : Array.from(contentEl.querySelectorAll('input[type="checkbox"]')).indexOf(checkboxEl);
  if (resolvedTaskIndex < 0) return;

  const nextChecked = typeof explicitChecked === 'boolean' ? explicitChecked : !checkboxEl.checked;
  const updatedRaw = toggleTaskInMarkdown(item.content, resolvedTaskIndex, nextChecked);
  if (!updatedRaw || updatedRaw === item.content) return;

  try {
    const filename = item.fileName || `${item.id}.md`;
    await saveFile(filename, updatedRaw);

    const itemIndex = items.findIndex(i => i.id === item.id);
    if (itemIndex !== -1) {
      items[itemIndex] = {
        ...items[itemIndex],
        content: updatedRaw,
        createdAt: Date.now()
      };
    }

    const { content } = parseFrontMatter(updatedRaw);
    renderNoteMarkdown(contentEl, content);
  } catch (err) {
    showPopup('Task update failed: ' + err.message, 'error');
  }
}

// ===== 编辑功能 =====
// 打开编辑弹窗
function openEditModal(item) {
  currentEditingItem = item;

  // 解析现有内容
  const { data, content } = parseFrontMatter(item.content);

  if (isLinkItemType(data.type)) {
    // 打开链接编辑弹窗
    openLinkEditModal(item, data);
  } else {
    // 打开笔记编辑弹窗
    openNoteEditModal(item, data, content);
  }
}

function getEditContent() {
  if (noteEditorView) {
    return noteEditorView.state.doc.toString();
  }
  return editModal.textarea.value;
}

function setEditContent(content) {
  const next = content || '';

  if (noteEditorView) {
    noteEditorView.dispatch({
      changes: { from: 0, to: noteEditorView.state.doc.length, insert: next }
    });
  }

  // 保持 textarea 与编辑器内容一致，作为降级兜底
  editModal.textarea.value = next;
}

function focusEditContent() {
  if (noteEditorView) {
    noteEditorView.focus();
    return;
  }
  editModal.textarea.focus();
}

function createHeadingExtension(StateField, Decoration, EditorView) {
  function buildDecorations(state) {
    const decorations = [];

    for (let i = 1; i <= state.doc.lines; i += 1) {
      const line = state.doc.line(i);
      const match = line.text.match(/^(#{1,6})\s/);
      if (!match) continue;

      const level = match[1].length;
      if (level === 1) {
        decorations.push(Decoration.line({ attributes: { class: 'cm-heading-1' } }).range(line.from));
      } else if (level === 2) {
        decorations.push(Decoration.line({ attributes: { class: 'cm-heading-2' } }).range(line.from));
      }
    }

    return Decoration.set(decorations);
  }

  return StateField.define({
    create(state) {
      return buildDecorations(state);
    },
    update(value, tr) {
      if (!tr.docChanged) return value;
      return buildDecorations(tr.state);
    },
    provide: (field) => EditorView.decorations.from(field)
  });
}

async function ensureNoteEditor() {
  if (noteEditorView) return true;
  if (noteEditorLoader) return noteEditorLoader;

  noteEditorLoader = (async () => {
    try {
      const [
        { EditorState, StateField },
        { EditorView, Decoration },
        { markdown, markdownLanguage },
        { HighlightStyle, syntaxHighlighting },
        { tags }
      ] = await Promise.all([
        import('https://esm.sh/@codemirror/state@6.5.4'),
        import('https://esm.sh/@codemirror/view@6.39.14'),
        import('https://esm.sh/@codemirror/lang-markdown@6.3.3'),
        import('https://esm.sh/@codemirror/language@6.12.1'),
        import('https://esm.sh/@lezer/highlight@1.2.3')
      ]);

      const headingExtension = createHeadingExtension(StateField, Decoration, EditorView);
      const syntaxHighlighter = HighlightStyle.define([
        { tag: tags.heading, fontWeight: '700' },
        { tag: tags.strong, fontWeight: '700' },
        { tag: tags.emphasis, fontStyle: 'italic' },
        { tag: tags.strikethrough, textDecoration: 'line-through' },
        { tag: tags.link, color: '#1a73e8' },
        { tag: tags.monospace, fontFamily: 'Roboto Mono, Consolas, monospace' }
      ]);

      noteEditorView = new EditorView({
        state: EditorState.create({
          doc: editModal.textarea.value || '',
          extensions: [
            markdown({ base: markdownLanguage }),
            syntaxHighlighting(syntaxHighlighter),
            headingExtension,
            EditorView.lineWrapping,
            EditorView.updateListener.of((update) => {
              if (update.docChanged) {
                updateCharCount(update.state.doc.toString());
                editModal.textarea.value = update.state.doc.toString();
              }
            }),
            EditorView.theme({
              '&': {
                height: '100%'
              },
              '.cm-scroller': {
                overflow: 'auto'
              },
              '.cm-gutters': {
                display: 'none'
              },
              '&.cm-focused': {
                outline: 'none'
              }
            })
          ]
        }),
        parent: editModal.editorContainer
      });

      editModal.editorContainer.classList.remove('hidden');
      editModal.textarea.classList.add('hidden');
      return true;
    } catch (error) {
      console.warn('CodeMirror load failed, fallback to textarea:', error);
      editModal.editorContainer.classList.add('hidden');
      editModal.textarea.classList.remove('hidden');
      return false;
    } finally {
      noteEditorLoader = null;
    }
  })();

  return noteEditorLoader;
}

// 打开笔记编辑弹窗
async function openNoteEditModal(item, data, content) {
  // 填充标题（使用 item.id，即文件名）
  editModal.titleInput.value = item.id;

  // 填充内容（不包含 front matter）
  setEditContent(content);
  updateCharCount(content);

  // 填充 tags
  const tags = data.tags ? data.tags.split(',').map(t => t.trim()) : [];
  editTagsInput.setTags(tags);

  // 重置保存按钮状态和错误状态
  editModal.saveBtn.disabled = false;
  editModal.saveBtn.textContent = 'Save';
  clearEditTitleError();

  editModal.modal.classList.remove('hidden');
  await ensureNoteEditor();
  setEditContent(content);
  focusEditContent();
}

// 打开链接编辑弹窗
function openLinkEditModal(item, data) {
  // 填充表单
  linkEditModal.form.title.value = data.title || '';
  linkEditModal.form.url.value = data.url || '';
  linkEditModal.form.description.value = data.description || '';
  linkEditModal.form.image.value = data.image || '';
  updateLinkCoverPreview(linkEditModal.form.image.value);

  // 填充 tags
  const tags = data.tags ? data.tags.split(',').map(t => t.trim()) : [];
  linkEditTagsInput.setTags(tags);

  linkEditModal.modal.classList.remove('hidden');
}

function updateLinkCoverPreview(imageUrl) {
  const trimmedUrl = (imageUrl || '').trim();
  if (!trimmedUrl) {
    linkEditModal.coverPreview.classList.add('hidden');
    linkEditModal.coverPreviewImage.removeAttribute('src');
    linkEditModal.coverPreviewHint.textContent = 'Cover preview unavailable';
    linkEditModal.coverPreviewHint.classList.add('hidden');
    return;
  }

  linkEditModal.coverPreview.classList.remove('hidden');
  linkEditModal.coverPreviewHint.textContent = 'Loading preview...';
  linkEditModal.coverPreviewHint.classList.remove('hidden');
  linkEditModal.coverPreviewImage.src = trimmedUrl;
}

// 关闭笔记编辑弹窗（自动保存）
async function closeEditModal() {
  if (!currentEditingItem) {
    editModal.modal.classList.add('hidden');
    return;
  }

  // 自动保存
  const saved = await saveEditedNote();
  if (saved) {
    editModal.modal.classList.add('hidden');
  } else {
    // 保存失败，保持模态框打开
  }
}

// 保存编辑
async function saveEditedNote() {
  if (!currentEditingItem) return false;

  const newContent = getEditContent().trim();
  if (!newContent) {
    showPopup('Content cannot be empty.', 'error');
    return false;
  }

  // 获取新标题并处理空标题（空标题回退到原标题）
  const newTitle = editModal.titleInput.value.trim();
  const finalTitle = newTitle || currentEditingItem.id;
  const sanitizedTitle = sanitizeFilename(finalTitle);

  // 重复检测（如果标题改变）
  if (sanitizedTitle !== currentEditingItem.id) {
    if (isTitleExists(sanitizedTitle, currentEditingItem.id)) {
      showEditTitleError('This title already exists. Please use a different title.');
      editModal.titleInput.focus();
      return false;
    }
  }

  // 获取 tags
  const tags = editTagsInput.getTags();

  const oldFilename = currentEditingItem.fileName;
  const newFilename = `${sanitizedTitle}.md`;
  const { data: originalData } = parseFrontMatter(currentEditingItem.content);
  const frontMatterData = { ...originalData, type: 'note' };
  delete frontMatterData.url;
  delete frontMatterData.image;
  delete frontMatterData.description;
  if (tags.length > 0) {
    frontMatterData.tags = tags.join(',');
  } else {
    delete frontMatterData.tags;
  }

  const finalContent = createMarkdownWithFrontMatter(frontMatterData, newContent);
  const hasFilenameChange = newFilename !== oldFilename;
  const hasContentChange = finalContent !== currentEditingItem.content;

  // 无改动时直接视为保存成功，不写文件、不更新时间
  if (!hasFilenameChange && !hasContentChange) {
    currentEditingItem = null;
    setEditContent('');
    editModal.titleInput.value = '';
    editTagsInput.clear();
    clearEditTitleError();
    return true;
  }

  editModal.saveBtn.disabled = true;
  editModal.saveBtn.textContent = 'Saving...';

  try {
    // 如果标题改变，执行文件重命名
    if (hasFilenameChange) {
      await renameFile(oldFilename, newFilename);
    }

    // 保存内容到文件（使用新文件名）
    await saveFile(newFilename, finalContent);

    // 更新内存
    const index = items.findIndex(i => i.id === currentEditingItem.id);
    if (index !== -1) {
      items[index] = {
        ...items[index],
        id: sanitizedTitle,
        content: finalContent,
        createdAt: Date.now(),
        fileName: newFilename
      };
    }

    // 更新 UI
    const oldId = currentEditingItem.id;
    const card = document.querySelector(`.card[data-id="${oldId}"]`);

    if (card) {
      // 更新 data-id 属性
      card.dataset.id = sanitizedTitle;

      // 更新标题
      const titleEl = card.querySelector('.note-title');
      if (titleEl) titleEl.textContent = sanitizedTitle;

      // 更新内容（完整 markdown 正文直接渲染）
      const contentEl = card.querySelector('.note-content');
      if (contentEl) {
        renderNoteMarkdown(contentEl, newContent);
      }

      // 更新 tags
      const tagsEl = card.querySelector('.card-tags');
      if (tagsEl) renderTags(tagsEl, tags);
    }

    // 重置状态
    currentEditingItem = null;
    setEditContent('');
    editModal.titleInput.value = '';
    editTagsInput.clear();
    clearEditTitleError();
    updateSidebarTags();

    return true;

  } catch (e) {
    console.error('Save failed:', e);
    showPopup('Save failed: ' + e.message, 'error');
    editModal.saveBtn.disabled = false;
    editModal.saveBtn.textContent = 'Save';
    return false;
  }
}

// 输入监听
function handleEditInput() {
  updateCharCount(getEditContent());
}

// 更新字符计数
function updateCharCount(content) {
  editModal.charCount.textContent = `${content.length} chars`;
}

// 绑定编辑弹窗事件
function bindEditModalEvents() {
  editModal.saveBtn.addEventListener('click', async () => {
    const saved = await saveEditedNote();
    if (saved) {
      editModal.modal.classList.add('hidden');
    }
  });
  editModal.backdrop.addEventListener('click', () => closeEditModal());
  editModal.textarea.addEventListener('input', handleEditInput);

  // 标题输入验证
  editModal.titleInput.addEventListener('input', handleEditTitleInput);

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && !editModal.modal.classList.contains('hidden')) {
      closeEditModal();
    }
  });

  editModal.modal.querySelector('.edit-modal-container')
    .addEventListener('click', (e) => e.stopPropagation());
}

// 绑定链接编辑弹窗事件
function bindLinkEditModalEvents() {
  linkEditModal.form.image.addEventListener('input', (e) => {
    updateLinkCoverPreview(e.target.value);
  });

  linkEditModal.coverPreviewImage.addEventListener('load', () => {
    linkEditModal.coverPreviewHint.textContent = '';
    linkEditModal.coverPreviewHint.classList.add('hidden');
  });

  linkEditModal.coverPreviewImage.addEventListener('error', () => {
    linkEditModal.coverPreviewHint.textContent = 'Cover preview unavailable';
    linkEditModal.coverPreviewHint.classList.remove('hidden');
  });

  linkEditModal.saveBtn.addEventListener('click', async () => {
    const saved = await saveLinkEdit();
    if (saved) {
      linkEditModal.modal.classList.add('hidden');
    }
  });
  linkEditModal.backdrop.addEventListener('click', () => closeLinkEditModal());

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && !linkEditModal.modal.classList.contains('hidden')) {
      closeLinkEditModal();
    }
  });

  linkEditModal.modal.querySelector('.edit-modal-container')
    .addEventListener('click', (e) => e.stopPropagation());
}

// 关闭链接编辑弹窗（自动保存）
async function closeLinkEditModal() {
  if (!currentEditingItem) {
    linkEditModal.modal.classList.add('hidden');
    return;
  }

  // 自动保存
  const saved = await saveLinkEdit();
  if (saved) {
    linkEditModal.modal.classList.add('hidden');
  }
}

// 保存链接编辑
async function saveLinkEdit() {
  if (!currentEditingItem) return false;

  const rawUrl = linkEditModal.form.url.value.trim();
  if (!rawUrl) {
    showPopup('Link cannot be empty.', 'error');
    return false;
  }
  if (!isValidUrl(rawUrl)) {
    showPopup('Invalid URL. Only http/https links are allowed.', 'error');
    return false;
  }

  // 获取表单数据
  const formData = {
    type: getLinkTypeFromUrl(rawUrl),
    title: linkEditModal.form.title.value.trim(),
    url: rawUrl,
    description: linkEditModal.form.description.value.trim(),
    image: linkEditModal.form.image.value.trim(),
  };

  if (!formData.url) {
    showPopup('Link cannot be empty.', 'error');
    return false;
  }

  const tags = linkEditTagsInput.getTags();
  if (tags.length > 0) {
    formData.tags = tags.join(',');
  }

  // 生成 front matter 内容
  const content = createMarkdownWithFrontMatter(formData);

  // 无改动时直接视为保存成功，不写文件、不更新时间
  if (content === currentEditingItem.content) {
    currentEditingItem = null;
    linkEditModal.form.reset();
    linkEditTagsInput.clear();
    return true;
  }

  linkEditModal.saveBtn.disabled = true;
  linkEditModal.saveBtn.textContent = 'Saving...';

  try {
    // 1. 保存到文件系统
    await saveFile(currentEditingItem.fileName, content);

    // 2. 更新内存
    const index = items.findIndex(i => i.id === currentEditingItem.id);
    if (index !== -1) {
      items[index].content = content;
      items[index].createdAt = Date.now();
    }

    // 3. 更新 UI（整卡替换，保证类型切换时样式正确）
    const card = document.querySelector(`.card[data-id="${currentEditingItem.id}"]`);
    if (card) {
      const nextCard = createLinkCard({ ...formData, id: currentEditingItem.id });
      card.replaceWith(nextCard);
      const tagsEl = nextCard.querySelector('.card-tags');
      if (tagsEl) renderTags(tagsEl, tags);
    }

    // 重置状态
    currentEditingItem = null;
    linkEditModal.form.reset();
    linkEditTagsInput.clear();

    // 重置按钮状态
    linkEditModal.saveBtn.disabled = false;
    linkEditModal.saveBtn.textContent = 'Save';
    updateSidebarTags();

    return true;

  } catch (e) {
    console.error('Save failed:', e);
    showPopup('Save failed: ' + e.message, 'error');
    linkEditModal.saveBtn.disabled = false;
    linkEditModal.saveBtn.textContent = 'Save';
    return false;
  }
}

// ===== 渲染 & 工具 (复用原有逻辑) =====
function renderItems() {
  filterAndRenderItems();
}

function renderOneItem(item, prepend) {
  const { data, content } = parseFrontMatter(item.content);
  let card;

  if (isLinkItemType(data.type)) {
    card = createLinkCard({ ...data, id: item.id });
  } else {
    // 使用 id（文件名）作为标题，正文保留完整 markdown 内容
    const title = item.id;

    // 解析 tags
    const tags = data.tags ? data.tags.split(',').map(t => t.trim()) : [];

    card = createNoteCard({
      id: item.id,
      title: title,
      content: content,
      tags: tags
    });
  }

  if (prepend) {
    elements.cardsGrid.prepend(card);
  } else {
    elements.cardsGrid.appendChild(card);
  }
}

// ... 保持 parseFrontMatter, createMarkdownWithFrontMatter, 
// createLinkCard, createNoteCard, createLoadingCard, 
// form control functions 一致 ...

// ===== 辅助函数实现 =====
function parseFrontMatter(text) {
  const pattern = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
  const match = text.match(pattern);
  if (!match) return { data: {}, content: text };

  const yaml = match[1];
  const content = match[2].trim();
  const data = {};
  yaml.split('\n').forEach(line => {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length > 0) {
      data[key.trim()] = valueParts.join(':').trim();
    }
  });
  return { data, content };
}

function createMarkdownWithFrontMatter(data, content = '') {
  let yaml = '---\n';
  Object.entries(data).forEach(([key, value]) => {
    if (value) yaml += `${key}: ${value}\n`;
  });
  yaml += '---\n';
  return yaml + content;
}

function expandNoteForm() {
  elements.addBoxCollapsed.classList.add('hidden');
  elements.noteForm.classList.remove('hidden');
  autoResizeNoteContentInput();
  elements.noteContentInput.focus();
}

function collapseForm() {
  elements.noteForm.classList.add('hidden');
  elements.addBoxCollapsed.classList.remove('hidden');
  autoResizeNoteContentInput();
}

function ensureXWidgetsLoaded() {
  if (window.twttr && window.twttr.widgets && typeof window.twttr.widgets.createTweet === 'function') {
    return Promise.resolve(window.twttr);
  }

  if (xWidgetsLoadPromise) return xWidgetsLoadPromise;

  xWidgetsLoadPromise = new Promise((resolve, reject) => {
    const onReady = () => {
      if (!window.twttr || typeof window.twttr.ready !== 'function') {
        reject(new Error('X widgets API unavailable'));
        return;
      }
      window.twttr.ready(() => resolve(window.twttr));
    };

    let script = document.getElementById(X_WIDGETS_SCRIPT_ID);
    if (!script) {
      script = document.createElement('script');
      script.id = X_WIDGETS_SCRIPT_ID;
      script.src = X_WIDGETS_SCRIPT_SRC;
      script.async = true;
      script.defer = true;
      script.charset = 'utf-8';
      document.head.appendChild(script);
    }

    if (window.twttr && window.twttr.widgets) {
      onReady();
      return;
    }

    script.addEventListener('load', onReady, { once: true });
    script.addEventListener('error', () => {
      reject(new Error('Failed to load X widgets.js'));
    }, { once: true });
  }).catch(error => {
    xWidgetsLoadPromise = null;
    throw error;
  });

  return xWidgetsLoadPromise;
}

function renderXPostEmbed(container, xPostId, postUrl) {
  const skeleton = document.createElement('div');
  skeleton.className = 'x-post-skeleton skeleton';
  skeleton.setAttribute('aria-hidden', 'true');
  container.appendChild(skeleton);

  const fallbackLink = document.createElement('a');
  fallbackLink.className = 'x-post-fallback-link';
  fallbackLink.href = postUrl;
  fallbackLink.target = '_blank';
  fallbackLink.rel = 'noopener noreferrer';
  fallbackLink.textContent = 'Open post on X';
  container.appendChild(fallbackLink);

  ensureXWidgetsLoaded()
    .then(twttr => twttr.widgets.createTweet(xPostId, container, {
      dnt: true,
      align: 'center'
    }))
    .then(tweetEl => {
      skeleton.remove();
      if (tweetEl) fallbackLink.remove();
    })
    .catch(error => {
      skeleton.remove();
      console.warn('Failed to render X post embed:', error);
    });
}

function createLinkCard(data) {
  const template = elements.linkCardTemplate.content.cloneNode(true);
  const card = template.querySelector('.card');
  card.dataset.id = data.id;

  // 设置打开链接按钮的 href
  const openLinkBtn = card.querySelector('.open-link-button');
  if (openLinkBtn) {
    const safeUrl = withHttpProtocol(data.url);
    openLinkBtn.href = safeUrl || '#';
  }

  const imageWrap = card.querySelector('.card-image');
  const img = card.querySelector('.card-image img');
  const titleEl = card.querySelector('.card-title');
  const descriptionEl = card.querySelector('.card-description');
  const bodyEl = card.querySelector('.card-body');
  const urlTextEl = card.querySelector('.url-text');

  const xPostId = extractXPostId(data.url);
  if (xPostId) {
    card.classList.add('x-post-card');
    if (imageWrap) imageWrap.classList.add('hidden');
    if (titleEl) titleEl.classList.add('hidden');
    if (descriptionEl) descriptionEl.classList.add('hidden');

    const embedWrap = document.createElement('div');
    embedWrap.className = 'x-post-embed';
    const xPostUrl = `https://x.com/i/web/status/${xPostId}`;
    renderXPostEmbed(embedWrap, xPostId, xPostUrl);
    bodyEl.prepend(embedWrap);
  } else {
    const directImageUrl = extractDirectImageUrl(data.url);
    const displayImageUrl = directImageUrl || data.image;

    if (directImageUrl) {
      card.classList.add('image-link-card');
    }

    if (displayImageUrl) {
      img.src = displayImageUrl;
      img.alt = data.title;
      img.onerror = () => img.classList.add('error');
    } else {
      img.classList.add('error');
    }

    titleEl.textContent = data.title;
    descriptionEl.textContent = data.description;
  }

  urlTextEl.textContent = extractDomain(data.url);

  // 渲染 tags
  const tags = data.tags ? data.tags.split(',').map(t => t.trim()) : [];
  const tagsEl = card.querySelector('.card-tags');
  if (tagsEl) {
    renderTags(tagsEl, tags);
  }

  return card;
}

function createNoteCard(data) {
  const template = elements.noteCardTemplate.content.cloneNode(true);
  const card = template.querySelector('.card');
  card.dataset.id = data.id;

  const titleEl = card.querySelector('.note-title');
  if (data.title) titleEl.textContent = data.title;

  const contentEl = card.querySelector('.note-content');
  if (data.content) {
    renderNoteMarkdown(contentEl, data.content);
  }

  // 渲染 tags
  const tags = data.tags || [];
  const tagsEl = card.querySelector('.card-tags');
  if (tagsEl) {
    renderTags(tagsEl, tags);
  }

  return card;
}

// 渲染 tags 到容器
function renderTags(container, tags) {
  container.innerHTML = '';
  if (!tags || tags.length === 0) return;

  tags.forEach(tag => {
    const tagEl = document.createElement('span');
    tagEl.className = 'tag';
    tagEl.textContent = tag;
    container.appendChild(tagEl);
  });
}

function createLoadingCard() {
  const template = elements.linkLoadingTemplate.content.cloneNode(true);
  return template.querySelector('.card');
}

function updateEmptyState() {
  if (searchQuery) {
    elements.emptyStateText.textContent = 'No results found';
  } else if (currentView === VIEW_TRASH) {
    elements.emptyStateText.textContent = 'No files in .trash';
  } else {
    elements.emptyStateText.textContent = 'Your links and notes will appear here';
  }
  const hasItems = elements.cardsGrid.children.length > 0;
  elements.emptyState.classList.toggle('hidden', hasItems);
}

// API Utils
async function fetchLinkMetadata(url) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000);
  try {
    const apiUrl = `${API_URL}?url=${encodeURIComponent(url)}&screenshot=true`;
    const response = await fetch(apiUrl, { signal: controller.signal });
    if (!response.ok) throw new Error('API request failed');
    const data = await response.json();
    if (data.status !== 'success') throw new Error('Failed to fetch');

    const imgData = data.data.image || {};
    const screenData = data.data.screenshot || {};
    const logoData = data.data.logo || {};

    // Choose best image
    let finalImage = imgData.url;

    // heuristic check for logo vs main image
    const w = imgData.width || 0;
    const h = imgData.height || 0;
    const isLogo = w < 400 || h < 200 || (w === h && w < 500);

    if (!finalImage || isLogo) {
      if (screenData.url) finalImage = screenData.url;
      else if (finalImage) { } // keep logo if no screenshot
      else if (logoData.url) finalImage = logoData.url;
    }

    const title = data.data.title || '';
    const description = data.data.description || '';
    const pageText = `${title}\n${description}`;
    const hasBlockedTitle = /error:\s*the request could not be satisfied|403\s*error/i.test(title);
    const matchedCloudFrontSignals = CLOUDFRONT_ERROR_PATTERNS.filter(pattern => pattern.test(pageText)).length;
    const isBlockedPage = hasBlockedTitle || matchedCloudFrontSignals >= 2;

    // Some sites return CDN error pages as metadata/screenshot. Do not persist them as cover/title.
    if (isBlockedPage) {
      finalImage = '';
    }

    return {
      title: isBlockedPage ? '' : title,
      description: isBlockedPage ? '' : description,
      image: finalImage
    };
  } finally {
    clearTimeout(timeoutId);
  }
}

function isValidUrl(string) {
  try {
    const url = new URL(string);
    return url.protocol === 'http:' || url.protocol === 'https:';
  } catch { return false; }
}

function extractXPostId(rawUrl) {
  try {
    const url = new URL(rawUrl);
    const host = url.hostname.toLowerCase().replace(/^www\./, '');
    const isXDomain = host === 'x.com' || host === 'twitter.com' || host === 'mobile.twitter.com';
    if (!isXDomain) return null;

    const match = url.pathname.match(/\/status\/(\d+)/i);
    return match ? match[1] : null;
  } catch {
    return null;
  }
}

function extractDirectImageUrl(rawUrl) {
  try {
    const url = new URL(rawUrl);
    const pathname = url.pathname.toLowerCase();
    const extMatch = pathname.match(/\.([a-z0-9]+)$/);
    const ext = extMatch ? extMatch[1] : '';
    const format = (url.searchParams.get('format') || '').toLowerCase();
    const imageExtSet = new Set(['jpg', 'jpeg', 'png', 'gif', 'webp', 'avif', 'bmp', 'svg']);

    if (imageExtSet.has(ext) || imageExtSet.has(format)) {
      return url.toString();
    }

    return null;
  } catch {
    return null;
  }
}

function getLinkTypeFromUrl(url) {
  return extractDirectImageUrl(url) ? 'image' : 'link';
}

function isLinkItemType(type) {
  return type === 'link' || type === 'image';
}

function normalizeItemTypeInContent(text) {
  const match = text.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  const hasFrontMatter = Boolean(match);
  const { data } = parseFrontMatter(text);
  const body = hasFrontMatter ? match[2] : text;

  const nextData = { ...data };
  if (nextData.url) {
    nextData.type = getLinkTypeFromUrl(nextData.url);
  } else {
    nextData.type = 'note';
  }

  if (hasFrontMatter) {
    if (nextData.type === data.type) return text;
    return createMarkdownWithFrontMatter(nextData, body);
  }

  return createMarkdownWithFrontMatter(nextData, body);
}

function extractDomain(url) {
  try { return new URL(url).hostname; } catch { return url; }
}

function extractReadableTitleFromUrl(rawUrl) {
  try {
    const url = new URL(rawUrl);
    const segments = url.pathname
      .split('/')
      .map(segment => segment.trim())
      .filter(Boolean)
      .filter(segment => !/^[a-z]{2}(-[a-z]{2})?$/i.test(segment)); // remove locale-like segment: en / en-US

    const candidate = segments.length > 0 ? segments[segments.length - 1] : '';
    if (!candidate) return extractDomain(rawUrl);

    const title = decodeURIComponent(candidate)
      .replace(/[-_]+/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    return title || extractDomain(rawUrl);
  } catch {
    return extractDomain(rawUrl);
  }
}

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2);
}

function sanitizeRenderedHtml(html) {
  const template = document.createElement('template');
  template.innerHTML = html;

  const blockedTags = new Set(['script', 'iframe', 'object', 'embed', 'link', 'style', 'meta', 'base']);
  const walker = document.createTreeWalker(template.content, NodeFilter.SHOW_ELEMENT);
  const toRemove = [];

  while (walker.nextNode()) {
    const el = walker.currentNode;
    const tagName = el.tagName.toLowerCase();
    if (blockedTags.has(tagName)) {
      toRemove.push(el);
      continue;
    }

    for (const attr of Array.from(el.attributes)) {
      const name = attr.name.toLowerCase();
      const value = attr.value.trim();
      const lowerValue = value.toLowerCase();
      if (name.startsWith('on')) {
        el.removeAttribute(attr.name);
        continue;
      }
      if ((name === 'href' || name === 'src') && (lowerValue.startsWith('javascript:') || lowerValue.startsWith('vbscript:'))) {
        el.removeAttribute(attr.name);
      }
    }
  }

  toRemove.forEach(node => node.remove());
  return template.innerHTML;
}

// 清理文件名中的非法字符
function sanitizeFilename(name) {
  // 移除或替换不适合文件系统的字符
  // Windows 不允许: < > : " / \ | ? *
  // 同时移除控制字符和前后空格
  let cleaned = name
    .replace(/[<>:"/\\|?*\x00-\x1f]/g, '') // 移除非法字符
    .replace(/\s+/g, ' ')  // 多个空格合并为一个
    .trim();               // 移除前后空格

  // 如果清理后为空，使用时间戳
  if (!cleaned) {
    cleaned = generateTimestampTitle();
  }

  // 限制长度（大多数文件系统限制255字符）
  if (cleaned.length > 200) {
    cleaned = cleaned.slice(0, 200);
  }

  return cleaned;
}

// 生成时间戳标题（当标题为空时使用）
function generateTimestampTitle() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');

  return `${year}${month}${day}${hours}${minutes}${seconds}`;
}

function ensureUniqueTitle(baseTitle, excludeId = null) {
  const sanitizedBase = sanitizeFilename(baseTitle || generateTimestampTitle());
  let candidate = sanitizedBase;
  let suffixNumber = 1;

  while (isTitleExists(candidate, excludeId)) {
    const suffix = `-${suffixNumber}`;
    const maxBaseLength = 200 - suffix.length;
    const base = sanitizedBase.length > maxBaseLength
      ? sanitizedBase.slice(0, maxBaseLength).trimEnd()
      : sanitizedBase;
    candidate = `${base}${suffix}`;
    suffixNumber += 1;
  }

  return candidate;
}

function withHttpProtocol(rawUrl) {
  const value = (rawUrl || '').trim();
  if (!value) return '';
  if (isValidUrl(value)) return value;
  const prefixed = `https://${value}`;
  return isValidUrl(prefixed) ? prefixed : '';
}

// ===== 标题验证相关 =====

// 检查标题是否已存在
function isTitleExists(title, excludeId = null) {
  const sanitizedTitle = sanitizeFilename(title);
  return items.some(item => {
    // 如果指定了 excludeId，排除该项
    if (excludeId && item.id === excludeId) return false;
    // 对于笔记，id 就是文件名（不含扩展名）
    // 对于链接，id 也是文件名（不含扩展名）
    return item.id === sanitizedTitle;
  });
}

// 标题输入处理
// ===== 编辑模态框专用的标题验证 =====
function handleEditTitleInput() {
  const title = editModal.titleInput.value.trim();

  if (!title) {
    clearEditTitleError();
    return;
  }

  // 排除当前正在编辑的项目
  if (isTitleExists(title, currentEditingItem?.id)) {
    showEditTitleError('This title already exists. Please use a different title.');
  } else {
    clearEditTitleError();
  }
}

function showEditTitleError(message) {
  editModal.titleError.textContent = message;
  editModal.titleError.classList.add('visible');
  editModal.titleInput.classList.add('error');
  editModal.saveBtn.disabled = true;
}

function clearEditTitleError() {
  editModal.titleError.textContent = '';
  editModal.titleError.classList.remove('visible');
  editModal.titleInput.classList.remove('error');
  editModal.saveBtn.disabled = false;
}

document.addEventListener('DOMContentLoaded', init);

/**
 * Keep 风格收藏应用 - 本地文件系统版
 * 功能：基于 File System Access API 直接读写本地 Markdown 文件
 */

// ===== 常量配置 =====
const API_URL = 'https://api.microlink.io';
const CLOUDFRONT_ERROR_PATTERNS = [
  /error:\s*the request could not be satisfied/i,
  /403\s*error/i,
  /generated by cloudfront/i,
  /request blocked/i
];
const DB_NAME = 'keep-db';
const STORE_NAME = 'handles';
const X_WIDGETS_SCRIPT_SRC = 'https://platform.twitter.com/widgets.js';
const X_WIDGETS_SCRIPT_ID = 'xWidgetsScript';

// ===== IndexedDB 简易封装 =====
const db = {
  db: null,
  async open() {
    if (this.db) return this.db;
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, 1);
      request.onupgradeneeded = (e) => {
        e.target.result.createObjectStore(STORE_NAME);
      };
      request.onsuccess = (e) => {
        this.db = e.target.result;
        resolve(this.db);
      };
      request.onerror = (e) => reject(e);
    });
  },
  async get(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },
  async set(key, value) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const req = store.put(value, key);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }
};

// ===== DOM 元素 =====
const elements = {
  // Layout containers
  folderPrompt: document.getElementById('folderPrompt'),
  mainContent: document.getElementById('mainContent'),
  promptTitle: document.querySelector('#folderPrompt h2'),
  promptDesc: document.querySelector('#folderPrompt p'),
  openFolderBtn: document.getElementById('openFolderBtn'),

  // Header
  folderName: document.getElementById('folderName'),
  changeFolderBtn: document.getElementById('changeFolderBtn'),

  // Input fields
  addSection: document.querySelector('.add-section'),
  addBox: document.getElementById('addBox'),
  addBoxCollapsed: document.getElementById('addBoxCollapsed'),
  noteForm: document.getElementById('noteForm'),

  // Note input
  noteContentInput: document.getElementById('noteContentInput'),
  closeNoteForm: document.getElementById('closeNoteForm'),
  saveNoteBtn: document.getElementById('saveNoteBtn'),

  // Cards
  cardsGrid: document.getElementById('cardsGrid'),
  emptyState: document.getElementById('emptyState'),
  emptyStateText: document.querySelector('#emptyState p'),

  // Templates
  linkCardTemplate: document.getElementById('linkCardTemplate'),
  linkLoadingTemplate: document.getElementById('linkLoadingTemplate'),
  noteCardTemplate: document.getElementById('noteCardTemplate'),

  // Sidebar elements
  sidebarOverlay: null, // lazily initialized in showSidebarOverlay
  sidebarToggleBtn: document.getElementById('sidebarToggleBtn'),
  sidebar: document.getElementById('tagSidebar'),
  closeSidebarBtn: document.getElementById('closeSidebarBtn'),
  viewNotesBtn: document.getElementById('viewNotesBtn'),
  viewTrashBtn: document.getElementById('viewTrashBtn'),
  searchInput: document.getElementById('searchInput'),
  clearSearchBtn: document.getElementById('clearSearchBtn'),
  typeFiltersCard: document.getElementById('typeFiltersCard'),
  typeFiltersList: document.getElementById('typeFiltersList'),
  tagsList: document.getElementById('tagsList'),
  tagsSection: document.getElementById('tagsSection'),
  activeFilters: document.getElementById('activeFilters'),
  activeFiltersList: document.getElementById('activeFiltersList'),
  clearAllFiltersBtn: document.getElementById('clearAllFilters'),
  noTagsState: document.getElementById('noTagsState'),
};

// ===== 编辑弹窗 DOM =====
const editModal = {
  modal: document.getElementById('editModal'),
  editorContainer: document.getElementById('editContentEditor'),
  textarea: document.getElementById('editContentTextarea'),
  titleInput: document.getElementById('editTitleInput'),
  titleError: document.getElementById('editTitleError'),
  tagsContainer: document.getElementById('editTagsContainer'),
  charCount: document.querySelector('.char-count'),
  saveBtn: document.querySelector('.btn-save-edit'),
  backdrop: document.querySelector('.edit-modal-backdrop')
};

// ===== 链接编辑弹窗 DOM =====
const linkEditModal = {
  modal: document.getElementById('linkEditModal'),
  form: document.getElementById('linkEditForm'),
  coverPreview: document.getElementById('linkCoverPreview'),
  coverPreviewImage: document.getElementById('linkCoverPreviewImage'),
  coverPreviewHint: document.getElementById('linkCoverPreviewHint'),
  tagsContainer: document.getElementById('linkEditTagsContainer'),
  saveBtn: document.querySelector('.btn-save-link-edit'),
  backdrop: document.querySelector('#linkEditModal .edit-modal-backdrop')
};

// ===== 状态管理 =====
let dirHandle = null;
let items = []; // { id, content, createdAt, handle }
const pendingUrls = new Set();
const VIEW_ACTIVE = 'active';
const VIEW_TRASH = 'trash';
let currentView = VIEW_ACTIVE;
let searchQuery = '';

// Tag filter state
let selectedTags = new Set();  // Selected tag names
let allTags = [];              // Unique tags with counts: [{ name: 'tech', count: 5 }, ...]
let selectedType = null;       // Selected type (single-select): note/link/image
let allTypes = [];             // Types with counts: [{ name: 'note', count: 3 }, ...]

// Edit-related state
let currentEditingItem = null;
let noteEditorView = null;
let noteEditorLoader = null;
let popupHideTimer = null;
let xWidgetsLoadPromise = null;

// TagsInput component instances
let editTagsInput = null;
let linkEditTagsInput = null;

function isTextEditingTarget(target) {
  if (!(target instanceof Element)) return false;

  const editingSelector = 'input, textarea, select, [contenteditable="true"], .tags-input-field, .tags-input-container';
  if (target.closest(editingSelector)) return true;

  const editableAncestor = target.closest('[contenteditable]');
  if (!editableAncestor) return false;

  const contentEditableValue = editableAncestor.getAttribute('contenteditable');
  return contentEditableValue !== 'false';
}

function isMetaOrCtrlEnter(e) {
  return e.key === 'Enter' && (e.metaKey || e.ctrlKey);
}

function isNoteFormOpen() {
  return !elements.noteForm.classList.contains('hidden');
}

function isNoteEditOpen() {
  return !editModal.modal.classList.contains('hidden');
}

function isLinkEditOpen() {
  return !linkEditModal.modal.classList.contains('hidden');
}

function autoResizeNoteContentInput() {
  const textarea = elements.noteContentInput;
  if (!textarea) return;

  const maxHeightValue = getComputedStyle(textarea).maxHeight;
  const maxHeight = Number.parseFloat(maxHeightValue);
  const safeMaxHeight = Number.isFinite(maxHeight) ? maxHeight : 220;

  textarea.style.height = 'auto';
  const nextHeight = Math.min(textarea.scrollHeight, safeMaxHeight);
  textarea.style.height = `${nextHeight}px`;
  textarea.style.overflowY = textarea.scrollHeight > safeMaxHeight ? 'auto' : 'hidden';
}

function showPopup(message, type = 'success') {
  let popup = document.getElementById('appPopup');
  if (!popup) {
    popup = document.createElement('div');
    popup.id = 'appPopup';
    popup.className = 'app-popup';
    popup.setAttribute('role', 'status');
    popup.setAttribute('aria-live', 'polite');
    document.body.appendChild(popup);
  }

  popup.textContent = message;
  popup.classList.remove('show', 'success', 'error');
  popup.classList.add(type === 'error' ? 'error' : 'success');

  // Force reflow to replay animation for rapid repeated copies.
  void popup.offsetHeight;
  popup.classList.add('show');

  if (popupHideTimer) clearTimeout(popupHideTimer);
  popupHideTimer = setTimeout(() => {
    popup.classList.remove('show');
  }, 1500);
}